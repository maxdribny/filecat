Directory Structure:
===================
.
    |- README.md
    |- ashes_embers.txt
    |- cmd
        |- filecat
            |- main.go
        |- releases
            |- v1.0
    |- combined_files.txt
    |- filecat.exe
    |- go.mod
    |- go.sum
    |- internal
        |- core
            |- config.go
            |- files.go
            |- tree.go
    |- releases
        |- v1.0
            |- filecat.exe

File Contents:
===============


.GO Files:
==========

// cmd\filecat\main.go
// cmd/filecat/main.go

package main

import (
	"fmt"
	"os"

	"github.com/charmbracelet/lipgloss"
	"github.com/maxdribny/filecat/internal/core"
	"github.com/spf13/cobra"
)

var (
	successStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("10")).Bold(true)

	errorStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("9")).Bold(true)

	infoStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("12"))

	helpStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("14"))
)

func main() {
	var rootCmd = &cobra.Command{
		Use:   "filecat",
		Short: "A tool to combine and analyze source files",
		Long: `filecat is a command line tool that helps you combine multiple file sources into one, 
generate directory trees, and analyze code files.

Examples:
  # Combine all .go files in the current directory into combined_files.txt
  filecat -e go

  # Combine all .java files from a specific directory, with tree view, into a custom output file
  filecat -e java -r "C:\path\to\project\src" -t -o "combined_java.txt"

  # Only count lines of code for .js files, without combining
  filecat -e js -r "./web/scripts" -c --no-combine

  # Combine all .py files, show directory tree, and copy to clipboard
  filecat -e py -t -y

  # Exclude specific directories when searching for .cpp files
  filecat -e cpp -x "tests,vendor,third_party"`,
		Example: `  filecat -e go
  filecat -e java -r "C:\path\to\project\src" -t -o output.txt
  filecat -e js,ts -r "./web" -c -t`,
		RunE: run,
	}

	// Define flags with improved descriptions
	rootCmd.Flags().StringP("ext", "e", "",
		`File extension(s) to search for (comma-separated, without dots)
Examples: "go" or "java,js,py"`)

	rootCmd.Flags().StringP("exclude", "x", "",
		`Directories to exclude (comma-separated)
Examples: "node_modules,dist" or "test,vendor"
Note: .git, .idea, .vscode, node_modules, build, and dist are excluded by default`)

	rootCmd.Flags().StringP("root", "r", ".",
		`Root directory to start search from
Examples: "." (current directory) or "C:\path\to\project\src"`)

	rootCmd.Flags().StringP("out", "o", "combined_files.txt",
		`Output file name
Example: "combined_code.txt"`)

	rootCmd.Flags().BoolP("count", "c", false,
		`Count lines of code and display total`)

	rootCmd.Flags().Bool("no-combine", false,
		`Skip combining files (useful with -c to only count lines)`)

	rootCmd.Flags().BoolP("tree", "t", false,
		`Show directory tree of matching files`)

	rootCmd.Flags().BoolP("copy", "y", false,
		`Copy output file contents to clipboard`)

	// Custom help template
	rootCmd.SetHelpFunc(func(cmd *cobra.Command, args []string) {
		fmt.Println(helpStyle.Render("\nfilecat - Source File Combiner and Analyzer"))
		fmt.Println(helpStyle.Render("=======================================\n"))
		cmd.Usage()
		fmt.Println()
		fmt.Println(helpStyle.Render("Common Usage Patterns:"))
		fmt.Println(helpStyle.Render("---------------------"))
		fmt.Println("1. Find and combine all .go files in current directory:")
		fmt.Println("   filecat -e go")
		fmt.Println()
		fmt.Println("2. Generate directory tree and count lines (without combining):")
		fmt.Println("   filecat -e java -t -c --no-combine")
		fmt.Println()
		fmt.Println("3. Combine files with specific extension from a directory and save to custom file:")
		fmt.Println("   filecat -e js -r \"./src\" -o \"javascript_code.txt\"")
		fmt.Println()
		fmt.Println("4. Work with multiple file extensions:")
		fmt.Println("   filecat -e \"js,ts,jsx\" -r \"./web\" -t")
		fmt.Println()
		fmt.Println("5. Combine files and copy result to clipboard:")
		fmt.Println("   filecat -e py -y")
		fmt.Println()
		fmt.Println(helpStyle.Render("Note: Flags can be specified in any order"))
	})

	if err := rootCmd.Execute(); err != nil {
		fmt.Println(errorStyle.Render(err.Error()))
		os.Exit(1)
	}
}

func run(cmd *cobra.Command, args []string) error {
	config, err := core.NewConfig(cmd)
	if err != nil {
		return err
	}

	fmt.Printf("\n%s\n", infoStyle.Render(fmt.Sprintf("Searching for %v", config.FileExtensions)))
	fmt.Printf("%s\n", infoStyle.Render(fmt.Sprintf("Excluding directories: %v", config.ExcludeDirs)))

	// Find all matching files
	files, err := core.FindFiles(config)
	if err != nil {
		return fmt.Errorf("error finding files: %w", err)
	}

	if len(files) == 0 {
		return fmt.Errorf("no files found with extensions: %v", config.FileExtensions)
	}

	totalLines := 0
	for _, file := range files {
		totalLines += file.LineCount
	}

	if config.ShowTree {
		tree := core.GenerateDirectoryTree(config.RootDir, config.ExcludeDirs, config.FileExtensions)
		fmt.Println("\nDirectory Structure:")
		fmt.Println("=====================")
		fmt.Println(tree)
	}

	// Always display count if -c/--count flag is set
	if config.CountLines {
		fmt.Println(successStyle.Render(
			fmt.Sprintf("Found %d files with a total of %d lines of code", len(files), totalLines)))
	}

	// Handle copy to clipboard with or without combining
	if config.CopyOutput {
		if config.NoCombine {
			// Generate content in memory without creating a file
			content, err := core.GenerateContent(files, config)
			if err != nil {
				return fmt.Errorf("error generating content: %w", err)
			}

			if err := core.CopyContentToClipboard(content); err != nil {
				fmt.Println(errorStyle.Render(fmt.Sprintf("Error copying to clipboard: %v", err)))
			} else {
				fmt.Println(successStyle.Render("Content copied to clipboard"))
			}
		}
	}

	// Skip combining files if --no-combine is set
	if config.NoCombine {
		return nil
	}

	// Combine files into output
	if err := core.CombineFiles(files, config); err != nil {
		return fmt.Errorf("error combining files: %w", err)
	}

	// Copy to clipboard if option specified (and not already done)
	if config.CopyOutput {
		if err := core.CopyToClipboard(config.OutputFile); err != nil {
			fmt.Println(errorStyle.Render(fmt.Sprintf("Error copying to clipboard: %v", err)))
		} else {
			fmt.Println(successStyle.Render("Content copied to clipboard"))
		}
	}

	fmt.Println(successStyle.Render(
		fmt.Sprintf("Combined %d files into %s with a total of %d lines of code.", len(files), config.OutputFile, totalLines)))

	return nil
}


// internal\core\config.go
package core

import (
	"fmt"
	"github.com/spf13/cobra"
	"strings"
)

type Config struct {
	ExcludeDirs    []string
	FileExtensions []string
	RootDir        string
	OutputFile     string
	CountLines     bool
	NoCombine      bool
	ShowTree       bool
	CopyOutput     bool
}

func NewConfig(cmd *cobra.Command) (Config, error) {
	var config Config

	// Get flags from Cobra command
	fileExtensions, _ := cmd.Flags().GetString("ext")
	excludes, _ := cmd.Flags().GetString("exclude")
	config.RootDir, _ = cmd.Flags().GetString("root")
	config.OutputFile, _ = cmd.Flags().GetString("out")
	config.CountLines, _ = cmd.Flags().GetBool("count")
	config.NoCombine, _ = cmd.Flags().GetBool("no-combine")
	config.ShowTree, _ = cmd.Flags().GetBool("tree")
	config.CopyOutput, _ = cmd.Flags().GetBool("copy")

	// If none is specified, match all the files
	if fileExtensions == "none" {
		// Use an empty string as a marker for "match all files"
		config.FileExtensions = []string{""}
	} else if fileExtensions == "" {
		// If no extension is specified, require the user to provide one or use "none"
		return config, fmt.Errorf("no file extensions specified. Use -e/--ext flag to specify extensions or use -e none to match all files")
	} else {
		// Normal case: parse specified extensions
		config.FileExtensions = strings.Split(fileExtensions, ",")
		for i, ext := range config.FileExtensions {
			// Skip empty extensions (could happen with "ext1,,ext2")
			if ext == "" {
				continue
			}

			if !strings.HasPrefix(ext, ".") {
				config.FileExtensions[i] = "." + ext
			}
		}

		// Filter out any empty extensions that might have resulted from the split
		var filteredExtensions []string
		for _, ext := range config.FileExtensions {
			if ext != "" {
				filteredExtensions = append(filteredExtensions, ext)
			}
		}
		config.FileExtensions = filteredExtensions

		if len(config.FileExtensions) == 0 {
			return config, fmt.Errorf("no valid file extensions specified. Use -e/--ext flag to specify extensions or use -e none to match all files")
		}
	}

	if excludes != "" {
		config.ExcludeDirs = strings.Split(excludes, ",")
	}

	defaultExcludes := []string{".git", ".idea", ".vscode", "node_modules", "build", "dist"}
	config.ExcludeDirs = append(config.ExcludeDirs, defaultExcludes...)

	return config, nil
}


// internal\core\files.go
// internal/core/files.go

package core

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/atotto/clipboard"
	"github.com/schollz/progressbar/v3"
)

type FileInfo struct {
	Path      string
	Ext       string
	LineCount int
}

func FindFiles(config Config) ([]FileInfo, error) {
	var files []FileInfo

	bar := progressbar.NewOptions(-1,
		progressbar.OptionSetDescription("Searching files..."),
		progressbar.OptionSetWidth(30),
		progressbar.OptionSetRenderBlankState(true),
	)

	// Check if we should match all files (when "none" was specified)
	matchAllFiles := false
	if len(config.FileExtensions) == 1 && config.FileExtensions[0] == "" {
		matchAllFiles = true
	}

	err := filepath.Walk(config.RootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		bar.Add(1)

		if info.IsDir() {
			for _, excludeDir := range config.ExcludeDirs {
				if strings.Contains(path, excludeDir) {
					return filepath.SkipDir

				}
			}
			return nil
		}

		// If we're matching all files or the extension matches
		if matchAllFiles {
			// Skip hidden files
			fileName := filepath.Base(path)
			if strings.HasPrefix(fileName, ".") {
				return nil
			}

			lineCount, err := countLines(path)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Warning, Could not count lines in %s: %v\n", path, err)
				return nil
			}

			files = append(files, FileInfo{
				Path:      path,
				Ext:       filepath.Ext(path),
				LineCount: lineCount,
			})

			return nil
		}

		ext := filepath.Ext(path)
		for _, validExt := range config.FileExtensions {
			if ext == validExt {
				lineCount, err := countLines(path)
				if err != nil {
					fmt.Fprintf(os.Stderr, "Warning, Could not count lines in %s: %v\n", path, err)
					continue
				}

				files = append(files, FileInfo{
					Path:      path,
					Ext:       ext,
					LineCount: lineCount,
				})
				break
			}
		}
		return nil
	})

	fmt.Println()

	// Sort files by extension and path
	sort.Slice(files, func(i, j int) bool {
		if files[i].Ext != files[j].Ext {
			return files[i].Ext < files[j].Ext
		}
		return files[i].Path < files[j].Path
	})

	return files, err
}

func CombineFiles(files []FileInfo, config Config) error {
	outFile, err := os.Create(config.OutputFile)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	writer := bufio.NewWriter(outFile)

	// WRite the tree directory
	tree := GenerateDirectoryTree(config.RootDir, config.ExcludeDirs, config.FileExtensions)
	fmt.Fprintln(writer, "Directory Structure:")
	fmt.Fprintln(writer, "===================")
	fmt.Fprintln(writer, tree)
	fmt.Fprintln(writer, "\nFile Contents:")
	fmt.Fprintln(writer, "===============\n")

	bar := progressbar.NewOptions(len(files),
		progressbar.OptionSetDescription("Combining files..."),
		progressbar.OptionSetWidth(30),
		progressbar.OptionSetRenderBlankState(true),
	)

	currentExt := ""
	for _, file := range files {
		bar.Add(1)

		if currentExt != file.Ext {
			currentExt = file.Ext
			fmt.Fprintf(writer, "\n%s Files:\n", strings.ToUpper(currentExt))
			fmt.Fprintln(writer, strings.Repeat("=", len(currentExt)+7))
			fmt.Fprintln(writer)
		}

		fmt.Fprintf(writer, "// %s\n", file.Path)
		content, err := os.ReadFile(file.Path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: could not read file %s: %v\n", file.Path, err)
			continue
		}

		fmt.Fprintln(writer, string(content))
		fmt.Fprintln(writer)
	}

	fmt.Println()
	return writer.Flush()
}

func countLines(filepath string) (int, error) {
	file, err := os.Open(filepath)
	if err != nil {
		return 0, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	lineCount := 0
	for scanner.Scan() {
		lineCount++
	}
	return lineCount, scanner.Err()
}

func CopyToClipboard(filepath string) error {
	content, err := os.ReadFile(filepath)
	if err != nil {
		return fmt.Errorf("failed to read file for clipboard: %w", err)
	}

	return clipboard.WriteAll(string(content))
}

func GenerateContent(files []FileInfo, config Config) (string, error) {
	var builder strings.Builder

	// Write the tree directory
	tree := GenerateDirectoryTree(config.RootDir, config.ExcludeDirs, config.FileExtensions)
	fmt.Fprintln(&builder, "Directory Structure:")
	fmt.Fprintln(&builder, "===================")
	fmt.Fprintln(&builder, tree)
	fmt.Fprintln(&builder, "\nFile Contents:")
	fmt.Fprintln(&builder, "===============\n")

	bar := progressbar.NewOptions(len(files),
		progressbar.OptionSetDescription("Processing files..."),
		progressbar.OptionSetWidth(30),
		progressbar.OptionSetRenderBlankState(true),
	)

	currentExt := ""
	for _, file := range files {
		bar.Add(1)

		if currentExt != file.Ext {
			currentExt = file.Ext
			fmt.Fprintf(&builder, "\n%s Files:\n", strings.ToUpper(currentExt))
			fmt.Fprintln(&builder, strings.Repeat("=", len(currentExt)+7))
			fmt.Fprintln(&builder)
		}

		fmt.Fprintf(&builder, "\\ %s\n", file.Path)
		content, err := os.ReadFile(file.Path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: could not read file %s: %v\n", file.Path, err)
			continue
		}

		fmt.Fprintln(&builder, string(content))
		fmt.Fprintln(&builder)
	}

	fmt.Println()
	return builder.String(), nil
}

func CopyContentToClipboard(content string) error {
	return clipboard.WriteAll(content)
}


// internal\core\tree.go
// internal/core/tree.go

package core

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func GenerateDirectoryTree(root string, excludeDirs, extensions []string) string {
	var tree []string

	// Check if we should match all files
	matchAllFiles := false
	if len(extensions) == 1 && extensions[0] == "" {
		matchAllFiles = true
	}

	var walk func(dir string, level int)
	walk = func(dir string, level int) {
		files, err := os.ReadDir(dir)
		if err != nil {
			return
		}

		prefix := strings.Repeat("    ", level)
		dirName := filepath.Base(dir)

		if level == 0 {
			tree = append(tree, dirName)
		} else {
			tree = append(tree, fmt.Sprintf("%s|- %s", prefix, dirName))
		}

		for _, file := range files {
			path := filepath.Join(dir, file.Name())

			if file.IsDir() {
				skip := false
				for _, excludeDir := range excludeDirs {
					if strings.Contains(path, excludeDir) {
						skip = true
						break
					}
				}
				if skip {
					continue
				}
				walk(path, level+1)
			} else {
				// Include all files or only files with matching extensions
				if matchAllFiles {
					// Skip hidden files
					if !strings.HasPrefix(file.Name(), ".") {
						tree = append(tree, fmt.Sprintf("%s    |- %s", prefix, file.Name()))
					}
				} else {
					ext := filepath.Ext(file.Name())
					for _, validExt := range extensions {
						if ext == validExt {
							tree = append(tree, fmt.Sprintf("%s    |- %s", prefix, file.Name()))
							break
						}
					}
				}
			}
		}
	}

	walk(root, 0)
	return strings.Join(tree, "\n")
}



.MD Files:
==========

// README.md
# filecat

A command line tool for combining and analyzing multiple files into a single output file. Written in Go.

## Features

- Combine multiple files into a single output file
- Generate directory tree structure
- Count lines of code
- Copy output to clipboard
- Exclude specific directories
- Support for multiple file extensions

## Installation

```bash
go install github.com/maxdribny/filecat/filecat@latest
```

## Usage

```bash
# Basic usage - combine all .go files
filecat

# Specify multiple file extensions
filecat -ext go,md,txt,cs

# Exclude specific directories
filecat -exclude vendor,tests -ext=go

# Just count lines of code
filecat -count -ext go,md,txt,cs

# Show directory tree
filecat -tree -ext go,cs

# Custom output file
filecat -out output.txt -ext go,cs

# Copy to clipboard
filecat -copy -ext go,cs
```

## Available Options

- `-ext` : Comma seperated list of file extensions to search for (default: "go")
- `-exclude` : Comma-seperated list of directories to exclude
- `-root` : Root directory to start search from (default: current directory)
- `out` : Output file name (default: "combined_files.txt")
- `-count` : Only count lines of code without combining files
- `-tree` : Show directory tree structure
- `-copy` : Copy output to clipboard

## License
MIT


.MOD Files:
===========

// go.mod
module github.com/maxdribny/filecat

go 1.24.0

require (
	github.com/atotto/clipboard v0.1.4
	github.com/charmbracelet/lipgloss v1.0.0
	github.com/schollz/progressbar/v3 v3.18.0
	github.com/spf13/cobra v1.8.1
)

require (
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/charmbracelet/x/ansi v0.4.2 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db // indirect
	github.com/muesli/termenv v0.15.2 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	golang.org/x/sys v0.29.0 // indirect
	golang.org/x/term v0.28.0 // indirect
)



.SUM Files:
===========

// go.sum
github.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=
github.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/charmbracelet/lipgloss v1.0.0 h1:O7VkGDvqEdGi93X+DeqsQ7PKHDgtQfF8j8/O2qFMQNg=
github.com/charmbracelet/lipgloss v1.0.0/go.mod h1:U5fy9Z+C38obMs+T+tJqst9VGzlOYGj4ri9reL3qUlo=
github.com/charmbracelet/x/ansi v0.4.2 h1:0JM6Aj/g/KC154/gOP4vfxun0ff6itogDYk41kof+qk=
github.com/charmbracelet/x/ansi v0.4.2/go.mod h1:dk73KoMTT5AX5BsX0KrqhsTqAnhZZoCBjs7dGWp4Ktw=
github.com/chengxilo/virtualterm v1.0.4 h1:Z6IpERbRVlfB8WkOmtbHiDbBANU7cimRIof7mk9/PwM=
github.com/chengxilo/virtualterm v1.0.4/go.mod h1:DyxxBZz/x1iqJjFxTFcr6/x+jSpqN0iwWCOK1q10rlY=
github.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=
github.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db h1:62I3jR2EmQ4l5rM/4FEfDWcRD+abF5XlKShorW5LRoQ=
github.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db/go.mod h1:l0dey0ia/Uv7NcFFVbCLtqEBQbrT4OCwCSKTEv6enCw=
github.com/muesli/termenv v0.15.2 h1:GohcuySI0QmI3wN8Ok9PtKGkgkFIk7y6Vpb5PvrY+Wo=
github.com/muesli/termenv v0.15.2/go.mod h1:Epx+iuz8sNs7mNKhxzH4fWXGNpZwUaJKRS1noLXviQ8=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/schollz/progressbar/v3 v3.18.0 h1:uXdoHABRFmNIjUfte/Ex7WtuyVslrw2wVPQmCN62HpA=
github.com/schollz/progressbar/v3 v3.18.0/go.mod h1:IsO3lpbaGuzh8zIMzgY3+J8l4C8GjO0Y9S69eFvNsec=
github.com/spf13/cobra v1.8.1 h1:e5/vxKd/rZsfSJMUX1agtjeTDf+qv1/JdBF8gg5k9ZM=
github.com/spf13/cobra v1.8.1/go.mod h1:wHxEcudfqmLYa8iTfL+OuZPbBZkmvliBWKIezN3kD9Y=
github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=
github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=
golang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/term v0.28.0 h1:/Ts8HFuMR2E6IP/jlo7QVLZHggjKQbhu/7H0LJFr3Gg=
golang.org/x/term v0.28.0/go.mod h1:Sw/lC2IAUZ92udQNf3WodGtn4k/XoLyZoh8v/8uiwek=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=



.TXT Files:
===========

// ashes_embers.txt
Directory Structure:
===================
src
    |- main
        |- java
            |- com
                |- ashesembers
                    |- AshesembersMod.java
                    |- client
                        |- particle
                            |- AshesParticle.java
                            |- EmbersParticle.java
                    |- init
                        |- AshesembersModParticleTypes.java
                        |- AshesembersModParticles.java
                    |- procedures
                        |- ParticleEffectsProcedure.java
        |- resources
            |- META-INF
            |- assets
                |- ashesembers
                    |- lang
                    |- particles
                    |- textures
                        |- particle

File Contents:
===============


.JAVA Files:
============

// C:\Users\Max\Desktop\ashes_and_embers\src\main\java\com\ashesembers\AshesembersMod.java
package com.ashesembers;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

import net.minecraftforge.network.simple.SimpleChannel;
import net.minecraftforge.network.NetworkRegistry;
import net.minecraftforge.network.NetworkEvent;
import net.minecraftforge.fml.util.thread.SidedThreadGroups;
import net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.event.TickEvent;
import net.minecraftforge.common.MinecraftForge;

import net.minecraft.resources.ResourceLocation;
import net.minecraft.network.FriendlyByteBuf;

import java.util.function.Supplier;
import java.util.function.Function;
import java.util.function.BiConsumer;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.List;
import java.util.Collection;
import java.util.ArrayList;
import java.util.AbstractMap;

import com.ashesembers.init.AshesembersModParticleTypes;

@Mod("ashesembers")
public class AshesembersMod {
	public static final Logger LOGGER = LogManager.getLogger(AshesembersMod.class);
	public static final String MODID = "ashesembers";

	public AshesembersMod() {
		// Start of user code block mod constructor
		// End of user code block mod constructor
		MinecraftForge.EVENT_BUS.register(this);
		IEventBus bus = FMLJavaModLoadingContext.get().getModEventBus();

		AshesembersModParticleTypes.REGISTRY.register(bus);

		// Start of user code block mod init
		// End of user code block mod init
	}

	// Start of user code block mod methods
	// End of user code block mod methods
	private static final String PROTOCOL_VERSION = "1";
	public static final SimpleChannel PACKET_HANDLER = NetworkRegistry.newSimpleChannel(new ResourceLocation(MODID, MODID), () -> PROTOCOL_VERSION, PROTOCOL_VERSION::equals, PROTOCOL_VERSION::equals);
	private static int messageID = 0;

	public static <T> void addNetworkMessage(Class<T> messageType, BiConsumer<T, FriendlyByteBuf> encoder, Function<FriendlyByteBuf, T> decoder, BiConsumer<T, Supplier<NetworkEvent.Context>> messageConsumer) {
		PACKET_HANDLER.registerMessage(messageID, messageType, encoder, decoder, messageConsumer);
		messageID++;
	}

	private static final Collection<AbstractMap.SimpleEntry<Runnable, Integer>> workQueue = new ConcurrentLinkedQueue<>();

	public static void queueServerWork(int tick, Runnable action) {
		if (Thread.currentThread().getThreadGroup() == SidedThreadGroups.SERVER)
			workQueue.add(new AbstractMap.SimpleEntry<>(action, tick));
	}

	@SubscribeEvent
	public void tick(TickEvent.ServerTickEvent event) {
		if (event.phase == TickEvent.Phase.END) {
			List<AbstractMap.SimpleEntry<Runnable, Integer>> actions = new ArrayList<>();
			workQueue.forEach(work -> {
				work.setValue(work.getValue() - 1);
				if (work.getValue() == 0)
					actions.add(work);
			});
			actions.forEach(e -> e.getKey().run());
			workQueue.removeAll(actions);
		}
	}
}


// C:\Users\Max\Desktop\ashes_and_embers\src\main\java\com\ashesembers\client\particle\AshesParticle.java
package com.ashesembers.client.particle;

import net.minecraftforge.api.distmarker.OnlyIn;
import net.minecraftforge.api.distmarker.Dist;

import net.minecraft.core.particles.SimpleParticleType;
import net.minecraft.client.particle.TextureSheetParticle;
import net.minecraft.client.particle.SpriteSet;
import net.minecraft.client.particle.ParticleRenderType;
import net.minecraft.client.particle.ParticleProvider;
import net.minecraft.client.particle.Particle;
import net.minecraft.client.multiplayer.ClientLevel;

@OnlyIn(Dist.CLIENT)
public class AshesParticle extends TextureSheetParticle {
	public static AshesParticleProvider provider(SpriteSet spriteSet) {
		return new AshesParticleProvider(spriteSet);
	}

	public static class AshesParticleProvider implements ParticleProvider<SimpleParticleType> {
		private final SpriteSet spriteSet;

		public AshesParticleProvider(SpriteSet spriteSet) {
			this.spriteSet = spriteSet;
		}

		public Particle createParticle(SimpleParticleType typeIn, ClientLevel worldIn, double x, double y, double z, double xSpeed, double ySpeed, double zSpeed) {
			return new AshesParticle(worldIn, x, y, z, xSpeed, ySpeed, zSpeed, this.spriteSet);
		}
	}

	private final SpriteSet spriteSet;

	protected AshesParticle(ClientLevel world, double x, double y, double z, double vx, double vy, double vz, SpriteSet spriteSet) {
		super(world, x, y, z);
		this.spriteSet = spriteSet;
		this.setSize(0.1f, 0.1f);
		this.quadSize *= 0.5f;
		this.lifetime = (int) Math.max(1, 100 + (this.random.nextInt(120) - 60));
		this.gravity = 0.1f;
		this.hasPhysics = true;
		this.xd = vx * 0;
		this.yd = vy * 0;
		this.zd = vz * 0;
		this.pickSprite(spriteSet);
	}

	@Override
	public ParticleRenderType getRenderType() {
		return ParticleRenderType.PARTICLE_SHEET_TRANSLUCENT;
	}

	@Override
	public void tick() {
		super.tick();
	}
}


// C:\Users\Max\Desktop\ashes_and_embers\src\main\java\com\ashesembers\client\particle\EmbersParticle.java
package com.ashesembers.client.particle;

import net.minecraftforge.api.distmarker.OnlyIn;
import net.minecraftforge.api.distmarker.Dist;

import net.minecraft.core.particles.SimpleParticleType;
import net.minecraft.client.particle.TextureSheetParticle;
import net.minecraft.client.particle.SpriteSet;
import net.minecraft.client.particle.ParticleRenderType;
import net.minecraft.client.particle.ParticleProvider;
import net.minecraft.client.particle.Particle;
import net.minecraft.client.multiplayer.ClientLevel;

@OnlyIn(Dist.CLIENT)
public class EmbersParticle extends TextureSheetParticle {
	public static EmbersParticleProvider provider(SpriteSet spriteSet) {
		return new EmbersParticleProvider(spriteSet);
	}

	public static class EmbersParticleProvider implements ParticleProvider<SimpleParticleType> {
		private final SpriteSet spriteSet;

		public EmbersParticleProvider(SpriteSet spriteSet) {
			this.spriteSet = spriteSet;
		}

		public Particle createParticle(SimpleParticleType typeIn, ClientLevel worldIn, double x, double y, double z, double xSpeed, double ySpeed, double zSpeed) {
			return new EmbersParticle(worldIn, x, y, z, xSpeed, ySpeed, zSpeed, this.spriteSet);
		}
	}

	private final SpriteSet spriteSet;

	protected EmbersParticle(ClientLevel world, double x, double y, double z, double vx, double vy, double vz, SpriteSet spriteSet) {
		super(world, x, y, z);
		this.spriteSet = spriteSet;
		this.setSize(0.2f, 0.2f);
		this.quadSize *= 0.3f;
		this.lifetime = (int) Math.max(1, 70 + (this.random.nextInt(100) - 50));
		this.gravity = 0.1f;
		this.hasPhysics = true;
		this.xd = vx * 0;
		this.yd = vy * 0;
		this.zd = vz * 0;
		this.pickSprite(spriteSet);
	}

	@Override
	public ParticleRenderType getRenderType() {
		return ParticleRenderType.PARTICLE_SHEET_TRANSLUCENT;
	}

	@Override
	public void tick() {
		super.tick();
	}
}


// C:\Users\Max\Desktop\ashes_and_embers\src\main\java\com\ashesembers\init\AshesembersModParticleTypes.java
package com.ashesembers.init;

import net.minecraftforge.registries.RegistryObject;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.DeferredRegister;

import net.minecraft.core.particles.SimpleParticleType;
import net.minecraft.core.particles.ParticleType;

import com.ashesembers.AshesembersMod;

public class AshesembersModParticleTypes {
	public static final DeferredRegister<ParticleType<?>> REGISTRY = DeferredRegister.create(ForgeRegistries.PARTICLE_TYPES, AshesembersMod.MODID);
	public static final RegistryObject<SimpleParticleType> ASHES = REGISTRY.register("ashes", () -> new SimpleParticleType(false));
	public static final RegistryObject<SimpleParticleType> EMBERS = REGISTRY.register("embers", () -> new SimpleParticleType(false));
}


// C:\Users\Max\Desktop\ashes_and_embers\src\main\java\com\ashesembers\init\AshesembersModParticles.java
package com.ashesembers.init;

import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.client.event.RegisterParticleProvidersEvent;
import net.minecraftforge.api.distmarker.Dist;

import com.ashesembers.client.particle.EmbersParticle;
import com.ashesembers.client.particle.AshesParticle;

@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD, value = Dist.CLIENT)
public class AshesembersModParticles {
	@SubscribeEvent
	public static void registerParticles(RegisterParticleProvidersEvent event) {
		event.registerSpriteSet(AshesembersModParticleTypes.ASHES.get(), AshesParticle::provider);
		event.registerSpriteSet(AshesembersModParticleTypes.EMBERS.get(), EmbersParticle::provider);
	}
}


// C:\Users\Max\Desktop\ashes_and_embers\src\main\java\com\ashesembers\procedures\ParticleEffectsProcedure.java
package com.ashesembers.procedures;

import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.eventbus.api.Event;
import net.minecraftforge.event.entity.living.LivingEvent;

import net.minecraft.world.level.LevelAccessor;
import net.minecraft.world.entity.Entity;
import net.minecraft.util.RandomSource;
import net.minecraft.util.Mth;
import net.minecraft.tags.TagKey;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.core.registries.Registries;
import net.minecraft.core.particles.SimpleParticleType;
import net.minecraft.core.BlockPos;

import javax.annotation.Nullable;

import com.ashesembers.init.AshesembersModParticleTypes;
import com.ashesembers.AshesembersMod;

@Mod.EventBusSubscriber
public class ParticleEffectsProcedure {
	@SubscribeEvent
	public static void onEntityTick(LivingEvent.LivingTickEvent event) {
		execute(event, event.getEntity().level(), event.getEntity().getX(), event.getEntity().getY(), event.getEntity().getZ(), event.getEntity());
	}

	public static void execute(LevelAccessor world, double x, double y, double z, Entity entity) {
		execute(null, world, x, y, z, entity);
	}

	private static void execute(@Nullable Event event, LevelAccessor world, double x, double y, double z, Entity entity) {
		if (entity == null)
			return;
		if (world.getBiome(BlockPos.containing(x, y, z)).is(TagKey.create(Registries.BIOME, new ResourceLocation("minecraft:is_overworld")))) {
			if (world.canSeeSkyFromBelowWater(BlockPos.containing(x, y, z))) {
				if (!entity.isUnderWater()) {
					AshesembersMod.queueServerWork(10, () -> {
						if (Math.random() < 0.4) {
							if (world instanceof ServerLevel _level)
								_level.sendParticles((SimpleParticleType) (AshesembersModParticleTypes.ASHES.get()), x, y, z, 28, (Mth.nextInt(RandomSource.create(), 1, 20)), (Mth.nextInt(RandomSource.create(), 3, 15)),
										(Mth.nextInt(RandomSource.create(), 1, 20)), 0.1);
						}
						if (Math.random() < 0.2) {
							if (world instanceof ServerLevel _level)
								_level.sendParticles((SimpleParticleType) (AshesembersModParticleTypes.EMBERS.get()), x, y, z, 20, (Mth.nextInt(RandomSource.create(), 1, 20)), (Mth.nextInt(RandomSource.create(), 3, 15)),
										(Mth.nextInt(RandomSource.create(), 1, 20)), 0.1);
						}
					});
				}
			}
		}
	}
}
}




// combined_files.txt
Directory Structure:
===================
.
    |- README.md
    |- ashes_embers.txt
    |- cmd
        |- filecat
            |- main.go
        |- releases
            |- v1.0
    |- combined_files.txt
    |- filecat.exe
    |- go.mod
    |- go.sum
    |- internal
        |- core
            |- config.go
            |- files.go
            |- tree.go
    |- releases
        |- v1.0
            |- filecat.exe

File Contents:
===============


.GO Files:
==========

// cmd\filecat\main.go
// cmd/filecat/main.go

package main

import (
	"fmt"
	"os"

	"github.com/charmbracelet/lipgloss"
	"github.com/maxdribny/filecat/internal/core"
	"github.com/spf13/cobra"
)

var (
	successStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("10")).Bold(true)

	errorStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("9")).Bold(true)

	infoStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("12"))

	helpStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("14"))
)

func main() {
	var rootCmd = &cobra.Command{
		Use:   "filecat",
		Short: "A tool to combine and analyze source files",
		Long: `filecat is a command line tool that helps you combine multiple file sources into one, 
generate directory trees, and analyze code files.

Examples:
  # Combine all .go files in the current directory into combined_files.txt
  filecat -e go

  # Combine all .java files from a specific directory, with tree view, into a custom output file
  filecat -e java -r "C:\path\to\project\src" -t -o "combined_java.txt"

  # Only count lines of code for .js files, without combining
  filecat -e js -r "./web/scripts" -c --no-combine

  # Combine all .py files, show directory tree, and copy to clipboard
  filecat -e py -t -y

  # Exclude specific directories when searching for .cpp files
  filecat -e cpp -x "tests,vendor,third_party"`,
		Example: `  filecat -e go
  filecat -e java -r "C:\path\to\project\src" -t -o output.txt
  filecat -e js,ts -r "./web" -c -t`,
		RunE: run,
	}

	// Define flags with improved descriptions
	rootCmd.Flags().StringP("ext", "e", "",
		`File extension(s) to search for (comma-separated, without dots)
Examples: "go" or "java,js,py"`)

	rootCmd.Flags().StringP("exclude", "x", "",
		`Directories to exclude (comma-separated)
Examples: "node_modules,dist" or "test,vendor"
Note: .git, .idea, .vscode, node_modules, build, and dist are excluded by default`)

	rootCmd.Flags().StringP("root", "r", ".",
		`Root directory to start search from
Examples: "." (current directory) or "C:\path\to\project\src"`)

	rootCmd.Flags().StringP("out", "o", "combined_files.txt",
		`Output file name
Example: "combined_code.txt"`)

	rootCmd.Flags().BoolP("count", "c", false,
		`Count lines of code and display total`)

	rootCmd.Flags().Bool("no-combine", false,
		`Skip combining files (useful with -c to only count lines)`)

	rootCmd.Flags().BoolP("tree", "t", false,
		`Show directory tree of matching files`)

	rootCmd.Flags().BoolP("copy", "y", false,
		`Copy output file contents to clipboard`)

	// Custom help template
	rootCmd.SetHelpFunc(func(cmd *cobra.Command, args []string) {
		fmt.Println(helpStyle.Render("\nfilecat - Source File Combiner and Analyzer"))
		fmt.Println(helpStyle.Render("=======================================\n"))
		cmd.Usage()
		fmt.Println()
		fmt.Println(helpStyle.Render("Common Usage Patterns:"))
		fmt.Println(helpStyle.Render("---------------------"))
		fmt.Println("1. Find and combine all .go files in current directory:")
		fmt.Println("   filecat -e go")
		fmt.Println()
		fmt.Println("2. Generate directory tree and count lines (without combining):")
		fmt.Println("   filecat -e java -t -c --no-combine")
		fmt.Println()
		fmt.Println("3. Combine files with specific extension from a directory and save to custom file:")
		fmt.Println("   filecat -e js -r \"./src\" -o \"javascript_code.txt\"")
		fmt.Println()
		fmt.Println("4. Work with multiple file extensions:")
		fmt.Println("   filecat -e \"js,ts,jsx\" -r \"./web\" -t")
		fmt.Println()
		fmt.Println("5. Combine files and copy result to clipboard:")
		fmt.Println("   filecat -e py -y")
		fmt.Println()
		fmt.Println(helpStyle.Render("Note: Flags can be specified in any order"))
	})

	if err := rootCmd.Execute(); err != nil {
		fmt.Println(errorStyle.Render(err.Error()))
		os.Exit(1)
	}
}

func run(cmd *cobra.Command, args []string) error {
	config, err := core.NewConfig(cmd)
	if err != nil {
		return err
	}

	fmt.Printf("\n%s\n", infoStyle.Render(fmt.Sprintf("Searching for %v", config.FileExtensions)))
	fmt.Printf("%s\n", infoStyle.Render(fmt.Sprintf("Excluding directories: %v", config.ExcludeDirs)))

	// Find all matching files
	files, err := core.FindFiles(config)
	if err != nil {
		return fmt.Errorf("error finding files: %w", err)
	}

	if len(files) == 0 {
		return fmt.Errorf("no files found with extensions: %v", config.FileExtensions)
	}

	totalLines := 0
	for _, file := range files {
		totalLines += file.LineCount
	}

	if config.ShowTree {
		tree := core.GenerateDirectoryTree(config.RootDir, config.ExcludeDirs, config.FileExtensions)
		fmt.Println("\nDirectory Structure:")
		fmt.Println("=====================")
		fmt.Println(tree)
	}

	// Always display count if -c/--count flag is set
	if config.CountLines {
		fmt.Println(successStyle.Render(
			fmt.Sprintf("Found %d files with a total of %d lines of code", len(files), totalLines)))
	}

	// Handle copy to clipboard with or without combining
	if config.CopyOutput {
		if config.NoCombine {
			// Generate content in memory without creating a file
			content, err := core.GenerateContent(files, config)
			if err != nil {
				return fmt.Errorf("error generating content: %w", err)
			}

			if err := core.CopyContentToClipboard(content); err != nil {
				fmt.Println(errorStyle.Render(fmt.Sprintf("Error copying to clipboard: %v", err)))
			} else {
				fmt.Println(successStyle.Render("Content copied to clipboard"))
			}
		}
	}

	// Skip combining files if --no-combine is set
	if config.NoCombine {
		return nil
	}

	// Combine files into output
	if err := core.CombineFiles(files, config); err != nil {
		return fmt.Errorf("error combining files: %w", err)
	}

	// Copy to clipboard if option specified (and not already done)
	if config.CopyOutput {
		if err := core.CopyToClipboard(config.OutputFile); err != nil {
			fmt.Println(errorStyle.Render(fmt.Sprintf("Error copying to clipboard: %v", err)))
		} else {
			fmt.Println(successStyle.Render("Content copied to clipboard"))
		}
	}

	fmt.Println(successStyle.Render(
		fmt.Sprintf("Combined %d files into %s with a total of %d lines of code.", len(files), config.OutputFile, totalLines)))

	return nil
}


// internal\core\config.go
package core

import (
	"fmt"
	"github.com/spf13/cobra"
	"strings"
)

type Config struct {
	ExcludeDirs    []string
	FileExtensions []string
	RootDir        string
	OutputFile     string
	CountLines     bool
	NoCombine      bool
	ShowTree       bool
	CopyOutput     bool
}

func NewConfig(cmd *cobra.Command) (Config, error) {
	var config Config

	// Get flags from Cobra command
	fileExtensions, _ := cmd.Flags().GetString("ext")
	excludes, _ := cmd.Flags().GetString("exclude")
	config.RootDir, _ = cmd.Flags().GetString("root")
	config.OutputFile, _ = cmd.Flags().GetString("out")
	config.CountLines, _ = cmd.Flags().GetBool("count")
	config.NoCombine, _ = cmd.Flags().GetBool("no-combine")
	config.ShowTree, _ = cmd.Flags().GetBool("tree")
	config.CopyOutput, _ = cmd.Flags().GetBool("copy")

	// If none is specified, match all the files
	if fileExtensions == "none" {
		// Use an empty string as a marker for "match all files"
		config.FileExtensions = []string{""}
	} else if fileExtensions == "" {
		// If no extension is specified, require the user to provide one or use "none"
		return config, fmt.Errorf("no file extensions specified. Use -e/--ext flag to specify extensions or use -e none to match all files")
	} else {
		// Normal case: parse specified extensions
		config.FileExtensions = strings.Split(fileExtensions, ",")
		for i, ext := range config.FileExtensions {
			// Skip empty extensions (could happen with "ext1,,ext2")
			if ext == "" {
				continue
			}

			if !strings.HasPrefix(ext, ".") {
				config.FileExtensions[i] = "." + ext
			}
		}

		// Filter out any empty extensions that might have resulted from the split
		var filteredExtensions []string
		for _, ext := range config.FileExtensions {
			if ext != "" {
				filteredExtensions = append(filteredExtensions, ext)
			}
		}
		config.FileExtensions = filteredExtensions

		if len(config.FileExtensions) == 0 {
			return config, fmt.Errorf("no valid file extensions specified. Use -e/--ext flag to specify extensions or use -e none to match all files")
		}
	}

	if excludes != "" {
		config.ExcludeDirs = strings.Split(excludes, ",")
	}

	defaultExcludes := []string{".git", ".idea", ".vscode", "node_modules", "build", "dist"}
	config.ExcludeDirs = append(config.ExcludeDirs, defaultExcludes...)

	return config, nil
}


// internal\core\files.go
// internal/core/files.go

package core

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/atotto/clipboard"
	"github.com/schollz/progressbar/v3"
)

type FileInfo struct {
	Path      string
	Ext       string
	LineCount int
}

func FindFiles(config Config) ([]FileInfo, error) {
	var files []FileInfo

	bar := progressbar.NewOptions(-1,
		progressbar.OptionSetDescription("Searching files..."),
		progressbar.OptionSetWidth(30),
		progressbar.OptionSetRenderBlankState(true),
	)

	// Check if we should match all files (when "none" was specified)
	matchAllFiles := false
	if len(config.FileExtensions) == 1 && config.FileExtensions[0] == "" {
		matchAllFiles = true
	}

	err := filepath.Walk(config.RootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		bar.Add(1)

		if info.IsDir() {
			for _, excludeDir := range config.ExcludeDirs {
				if strings.Contains(path, excludeDir) {
					return filepath.SkipDir

				}
			}
			return nil
		}

		// If we're matching all files or the extension matches
		if matchAllFiles {
			// Skip hidden files
			fileName := filepath.Base(path)
			if strings.HasPrefix(fileName, ".") {
				return nil
			}

			lineCount, err := countLines(path)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Warning, Could not count lines in %s: %v\n", path, err)
				return nil
			}

			files = append(files, FileInfo{
				Path:      path,
				Ext:       filepath.Ext(path),
				LineCount: lineCount,
			})

			return nil
		}

		ext := filepath.Ext(path)
		for _, validExt := range config.FileExtensions {
			if ext == validExt {
				lineCount, err := countLines(path)
				if err != nil {
					fmt.Fprintf(os.Stderr, "Warning, Could not count lines in %s: %v\n", path, err)
					continue
				}

				files = append(files, FileInfo{
					Path:      path,
					Ext:       ext,
					LineCount: lineCount,
				})
				break
			}
		}
		return nil
	})

	fmt.Println()

	// Sort files by extension and path
	sort.Slice(files, func(i, j int) bool {
		if files[i].Ext != files[j].Ext {
			return files[i].Ext < files[j].Ext
		}
		return files[i].Path < files[j].Path
	})

	return files, err
}

func CombineFiles(files []FileInfo, config Config) error {
	outFile, err := os.Create(config.OutputFile)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	writer := bufio.NewWriter(outFile)

	// WRite the tree directory
	tree := GenerateDirectoryTree(config.RootDir, config.ExcludeDirs, config.FileExtensions)
	fmt.Fprintln(writer, "Directory Structure:")
	fmt.Fprintln(writer, "===================")
	fmt.Fprintln(writer, tree)
	fmt.Fprintln(writer, "\nFile Contents:")
	fmt.Fprintln(writer, "===============\n")

	bar := progressbar.NewOptions(len(files),
		progressbar.OptionSetDescription("Combining files..."),
		progressbar.OptionSetWidth(30),
		progressbar.OptionSetRenderBlankState(true),
	)

	currentExt := ""
	for _, file := range files {
		bar.Add(1)

		if currentExt != file.Ext {
			currentExt = file.Ext
			fmt.Fprintf(writer, "\n%s Files:\n", strings.ToUpper(currentExt))
			fmt.Fprintln(writer, strings.Repeat("=", len(currentExt)+7))
			fmt.Fprintln(writer)
		}

		fmt.Fprintf(writer, "// %s\n", file.Path)
		content, err := os.ReadFile(file.Path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: could not read file %s: %v\n", file.Path, err)
			continue
		}

		fmt.Fprintln(writer, string(content))
		fmt.Fprintln(writer)
	}

	fmt.Println()
	return writer.Flush()
}

func countLines(filepath string) (int, error) {
	file, err := os.Open(filepath)
	if err != nil {
		return 0, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	lineCount := 0
	for scanner.Scan() {
		lineCount++
	}
	return lineCount, scanner.Err()
}

func CopyToClipboard(filepath string) error {
	content, err := os.ReadFile(filepath)
	if err != nil {
		return fmt.Errorf("failed to read file for clipboard: %w", err)
	}

	return clipboard.WriteAll(string(content))
}

func GenerateContent(files []FileInfo, config Config) (string, error) {
	var builder strings.Builder

	// Write the tree directory
	tree := GenerateDirectoryTree(config.RootDir, config.ExcludeDirs, config.FileExtensions)
	fmt.Fprintln(&builder, "Directory Structure:")
	fmt.Fprintln(&builder, "===================")
	fmt.Fprintln(&builder, tree)
	fmt.Fprintln(&builder, "\nFile Contents:")
	fmt.Fprintln(&builder, "===============\n")

	bar := progressbar.NewOptions(len(files),
		progressbar.OptionSetDescription("Processing files..."),
		progressbar.OptionSetWidth(30),
		progressbar.OptionSetRenderBlankState(true),
	)

	currentExt := ""
	for _, file := range files {
		bar.Add(1)

		if currentExt != file.Ext {
			currentExt = file.Ext
			fmt.Fprintf(&builder, "\n%s Files:\n", strings.ToUpper(currentExt))
			fmt.Fprintln(&builder, strings.Repeat("=", len(currentExt)+7))
			fmt.Fprintln(&builder)
		}

		fmt.Fprintf(&builder, "\\ %s\n", file.Path)
		content, err := os.ReadFile(file.Path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: could not read file %s: %v\n", file.Path, err)
			continue
		}

		fmt.Fprintln(&builder, string(content))
		fmt.Fprintln(&builder)
	}

	fmt.Println()
	return builder.String(), nil
}

func CopyContentToClipboard(content string) error {
	return clipboard.WriteAll(content)
}


// internal\core\tree.go
// internal/core/tree.go

package core

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func GenerateDirectoryTree(root string, excludeDirs, extensions []string) string {
	var tree []string

	// Check if we should match all files
	matchAllFiles := false
	if len(extensions) == 1 && extensions[0] == "" {
		matchAllFiles = true
	}

	var walk func(dir string, level int)
	walk = func(dir string, level int) {
		files, err := os.ReadDir(dir)
		if err != nil {
			return
		}

		prefix := strings.Repeat("    ", level)
		dirName := filepath.Base(dir)

		if level == 0 {
			tree = append(tree, dirName)
		} else {
			tree = append(tree, fmt.Sprintf("%s|- %s", prefix, dirName))
		}

		for _, file := range files {
			path := filepath.Join(dir, file.Name())

			if file.IsDir() {
				skip := false
				for _, excludeDir := range excludeDirs {
					if strings.Contains(path, excludeDir) {
						skip = true
						break
					}
				}
				if skip {
					continue
				}
				walk(path, level+1)
			} else {
				// Include all files or only files with matching extensions
				if matchAllFiles {
					// Skip hidden files
					if !strings.HasPrefix(file.Name(), ".") {
						tree = append(tree, fmt.Sprintf("%s    |- %s", prefix, file.Name()))
					}
				} else {
					ext := filepath.Ext(file.Name())
					for _, validExt := range extensions {
						if ext == validExt {
							tree = append(tree, fmt.Sprintf("%s    |- %s", prefix, file.Name()))
							break
						}
					}
				}
			}
		}
	}

	walk(root, 0)
	return strings.Join(tree, "\n")
}



.MD Files:
==========

// README.md
# filecat

A command line tool for combining and analyzing multiple files into a single output file. Written in Go.

## Features

- Combine multiple files into a single output file
- Generate directory tree structure
- Count lines of code
- Copy output to clipboard
- Exclude specific directories
- Support for multiple file extensions

## Installation

```bash
go install github.com/maxdribny/filecat/filecat@latest
```

## Usage

```bash
# Basic usage - combine all .go files
filecat

# Specify multiple file extensions
filecat -ext go,md,txt,cs

# Exclude specific directories
filecat -exclude vendor,tests -ext=go

# Just count lines of code
filecat -count -ext go,md,txt,cs

# Show directory tree
filecat -tree -ext go,cs

# Custom output file
filecat -out output.txt -ext go,cs

# Copy to clipboard
filecat -copy -ext go,cs
```

## Available Options

- `-ext` : Comma seperated list of file extensions to search for (default: "go")
- `-exclude` : Comma-seperated list of directories to exclude
- `-root` : Root directory to start search from (default: current directory)
- `out` : Output file name (default: "combined_files.txt")
- `-count` : Only count lines of code without combining files
- `-tree` : Show directory tree structure
- `-copy` : Copy output to clipboard

## License
MIT


.MOD Files:
===========

// go.mod
module github.com/maxdribny/filecat

go 1.24.0

require (
	github.com/atotto/clipboard v0.1.4
	github.com/charmbracelet/lipgloss v1.0.0
	github.com/schollz/progressbar/v3 v3.18.0
	github.com/spf13/cobra v1.8.1
)

require (
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/charmbracelet/x/ansi v0.4.2 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db // indirect
	github.com/muesli/termenv v0.15.2 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	golang.org/x/sys v0.29.0 // indirect
	golang.org/x/term v0.28.0 // indirect
)



.SUM Files:
===========

// go.sum
github.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=
github.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/charmbracelet/lipgloss v1.0.0 h1:O7VkGDvqEdGi93X+DeqsQ7PKHDgtQfF8j8/O2qFMQNg=
github.com/charmbracelet/lipgloss v1.0.0/go.mod h1:U5fy9Z+C38obMs+T+tJqst9VGzlOYGj4ri9reL3qUlo=
github.com/charmbracelet/x/ansi v0.4.2 h1:0JM6Aj/g/KC154/gOP4vfxun0ff6itogDYk41kof+qk=
github.com/charmbracelet/x/ansi v0.4.2/go.mod h1:dk73KoMTT5AX5BsX0KrqhsTqAnhZZoCBjs7dGWp4Ktw=
github.com/chengxilo/virtualterm v1.0.4 h1:Z6IpERbRVlfB8WkOmtbHiDbBANU7cimRIof7mk9/PwM=
github.com/chengxilo/virtualterm v1.0.4/go.mod h1:DyxxBZz/x1iqJjFxTFcr6/x+jSpqN0iwWCOK1q10rlY=
github.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=
github.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db h1:62I3jR2EmQ4l5rM/4FEfDWcRD+abF5XlKShorW5LRoQ=
github.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db/go.mod h1:l0dey0ia/Uv7NcFFVbCLtqEBQbrT4OCwCSKTEv6enCw=
github.com/muesli/termenv v0.15.2 h1:GohcuySI0QmI3wN8Ok9PtKGkgkFIk7y6Vpb5PvrY+Wo=
github.com/muesli/termenv v0.15.2/go.mod h1:Epx+iuz8sNs7mNKhxzH4fWXGNpZwUaJKRS1noLXviQ8=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/schollz/progressbar/v3 v3.18.0 h1:uXdoHABRFmNIjUfte/Ex7WtuyVslrw2wVPQmCN62HpA=
github.com/schollz/progressbar/v3 v3.18.0/go.mod h1:IsO3lpbaGuzh8zIMzgY3+J8l4C8GjO0Y9S69eFvNsec=
github.com/spf13/cobra v1.8.1 h1:e5/vxKd/rZsfSJMUX1agtjeTDf+qv1/JdBF8gg5k9ZM=
github.com/spf13/cobra v1.8.1/go.mod h1:wHxEcudfqmLYa8iTfL+OuZPbBZkmvliBWKIezN3kD9Y=
github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=
github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=
golang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/term v0.28.0 h1:/Ts8HFuMR2E6IP/jlo7QVLZHggjKQbhu/7H0LJFr3Gg=
golang.org/x/term v0.28.0/go.mod h1:Sw/lC2IAUZ92udQNf3WodGtn4k/XoLyZoh8v/8uiwek=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=



.TXT Files:
===========

// ashes_embers.txt
Directory Structure:
===================
src
    |- main
        |- java
            |- com
                |- ashesembers
                    |- AshesembersMod.java
                    |- client
                        |- particle
                            |- AshesParticle.java
                            |- EmbersParticle.java
                    |- init
                        |- AshesembersModParticleTypes.java
                        |- AshesembersModParticles.java
                    |- procedures
                        |- ParticleEffectsProcedure.java
        |- resources
            |- META-INF
            |- assets
                |- ashesembers
                    |- lang
                    |- particles
                    |- textures
                        |- particle

File Contents:
===============


.JAVA Files:
============

// C:\Users\Max\Desktop\ashes_and_embers\src\main\java\com\ashesembers\AshesembersMod.java
package com.ashesembers;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

import net.minecraftforge.network.simple.SimpleChannel;
import net.minecraftforge.network.NetworkRegistry;
import net.minecraftforge.network.NetworkEvent;
import net.minecraftforge.fml.util.thread.SidedThreadGroups;
import net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.event.TickEvent;
import net.minecraftforge.common.MinecraftForge;

import net.minecraft.resources.ResourceLocation;
import net.minecraft.network.FriendlyByteBuf;

import java.util.function.Supplier;
import java.util.function.Function;
import java.util.function.BiConsumer;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.List;
import java.util.Collection;
import java.util.ArrayList;
import java.util.AbstractMap;

import com.ashesembers.init.AshesembersModParticleTypes;

@Mod("ashesembers")
public class AshesembersMod {
	public static final Logger LOGGER = LogManager.getLogger(AshesembersMod.class);
	public static final String MODID = "ashesembers";

	public AshesembersMod() {
		// Start of user code block mod constructor
		// End of user code block mod constructor
		MinecraftForge.EVENT_BUS.register(this);
		IEventBus bus = FMLJavaModLoadingContext.get().getModEventBus();

		AshesembersModParticleTypes.REGISTRY.register(bus);

		// Start of user code block mod init
		// End of user code block mod init
	}

	// Start of user code block mod methods
	// End of user code block mod methods
	private static final String PROTOCOL_VERSION = "1";
	public static final SimpleChannel PACKET_HANDLER = NetworkRegistry.newSimpleChannel(new ResourceLocation(MODID, MODID), () -> PROTOCOL_VERSION, PROTOCOL_VERSION::equals, PROTOCOL_VERSION::equals);
	private static int messageID = 0;

	public static <T> void addNetworkMessage(Class<T> messageType, BiConsumer<T, FriendlyByteBuf> encoder, Function<FriendlyByteBuf, T> decoder, BiConsumer<T, Supplier<NetworkEvent.Context>> messageConsumer) {
		PACKET_HANDLER.registerMessage(messageID, messageType, encoder, decoder, messageConsumer);
		messageID++;
	}

	private static final Collection<AbstractMap.SimpleEntry<Runnable, Integer>> workQueue = new ConcurrentLinkedQueue<>();

	public static void queueServerWork(int tick, Runnable action) {
		if (Thread.currentThread().getThreadGroup() == SidedThreadGroups.SERVER)
			workQueue.add(new AbstractMap.SimpleEntry<>(action, tick));
	}

	@SubscribeEvent
	public void tick(TickEvent.ServerTickEvent event) {
		if (event.phase == TickEvent.Phase.END) {
			List<AbstractMap.SimpleEntry<Runnable, Integer>> actions = new ArrayList<>();
			workQueue.forEach(work -> {
				work.setValue(work.getValue() - 1);
				if (work.getValue() == 0)
					actions.add(work);
			});
			actions.forEach(e -> e.getKey().run());
			workQueue.removeAll(actions);
		}
	}
}


// C:\Users\Max\Desktop\ashes_and_embers\src\main\java\com\ashesembers\client\particle\AshesParticle.java
package com.ashesembers.client.particle;

import net.minecraftforge.api.distmarker.OnlyIn;
import net.minecraftforge.api.distmarker.Dist;

import net.minecraft.core.particles.SimpleParticleType;
import net.minecraft.client.particle.TextureSheetParticle;
import net.minecraft.client.particle.SpriteSet;
import net.minecraft.client.particle.ParticleRenderType;
import net.minecraft.client.particle.ParticleProvider;
import net.minecraft.client.particle.Particle;
import net.minecraft.client.multiplayer.ClientLevel;

@OnlyIn(Dist.CLIENT)
public class AshesParticle extends TextureSheetParticle {
	public static AshesParticleProvider provider(SpriteSet spriteSet) {
		return new AshesParticleProvider(spriteSet);
	}

	public static class AshesParticleProvider implements ParticleProvider<SimpleParticleType> {
		private final SpriteSet spriteSet;

		public AshesParticleProvider(SpriteSet spriteSet) {
			this.spriteSet = spriteSet;
		}

		public Particle createParticle(SimpleParticleType typeIn, ClientLevel worldIn, double x, double y, double z, double xSpeed, double ySpeed, double zSpeed) {
			return new AshesParticle(worldIn, x, y, z, xSpeed, ySpeed, zSpeed, this.spriteSet);
		}
	}

	private final SpriteSet spriteSet;

	protected AshesParticle(ClientLevel world, double x, double y, double z, double vx, double vy, double vz, SpriteSet spriteSet) {
		super(world, x, y, z);
		this.spriteSet = spriteSet;
		this.setSize(0.1f, 0.1f);
		this.quadSize *= 0.5f;
		this.lifetime = (int) Math.max(1, 100 + (this.random.nextInt(120) - 60));
		this.gravity = 0.1f;
		this.hasPhysics = true;
		this.xd = vx * 0;
		this.yd = vy * 0;
		this.zd = vz * 0;
		this.pickSprite(spriteSet);
	}

	@Override
	public ParticleRenderType getRenderType() {
		return ParticleRenderType.PARTICLE_SHEET_TRANSLUCENT;
	}

	@Override
	public void tick() {
		super.tick();
	}
}


// C:\Users\Max\Desktop\ashes_and_embers\src\main\java\com\ashesembers\client\particle\EmbersParticle.java
package com.ashesembers.client.particle;

import net.minecraftforge.api.distmarker.OnlyIn;
import net.minecraftforge.api.distmarker.Dist;

import net.minecraft.core.particles.SimpleParticleType;
import net.minecraft.client.particle.TextureSheetParticle;
import net.minecraft.client.particle.SpriteSet;
import net.minecraft.client.particle.ParticleRenderType;
import net.minecraft.client.particle.ParticleProvider;
import net.minecraft.client.particle.Particle;
import net.minecraft.client.multiplayer.ClientLevel;

@OnlyIn(Dist.CLIENT)
public class EmbersParticle extends TextureSheetParticle {
	public static EmbersParticleProvider provider(SpriteSet spriteSet) {
		return new EmbersParticleProvider(spriteSet);
	}

	public static class EmbersParticleProvider implements ParticleProvider<SimpleParticleType> {
		private final SpriteSet spriteSet;

		public EmbersParticleProvider(SpriteSet spriteSet) {
			this.spriteSet = spriteSet;
		}

		public Particle createParticle(SimpleParticleType typeIn, ClientLevel worldIn, double x, double y, double z, double xSpeed, double ySpeed, double zSpeed) {
			return new EmbersParticle(worldIn, x, y, z, xSpeed, ySpeed, zSpeed, this.spriteSet);
		}
	}

	private final SpriteSet spriteSet;

	protected EmbersParticle(ClientLevel world, double x, double y, double z, double vx, double vy, double vz, SpriteSet spriteSet) {
		super(world, x, y, z);
		this.spriteSet = spriteSet;
		this.setSize(0.2f, 0.2f);
		this.quadSize *= 0.3f;
		this.lifetime = (int) Math.max(1, 70 + (this.random.nextInt(100) - 50));
		this.gravity = 0.1f;
		this.hasPhysics = true;
		this.xd = vx * 0;
		this.yd = vy * 0;
		this.zd = vz * 0;
		this.pickSprite(spriteSet);
	}

	@Override
	public ParticleRenderType getRenderType() {
		return ParticleRenderType.PARTICLE_SHEET_TRANSLUCENT;
	}

	@Override
	public void tick() {
		super.tick();
	}
}


// C:\Users\Max\Desktop\ashes_and_embers\src\main\java\com\ashesembers\init\AshesembersModParticleTypes.java
package com.ashesembers.init;

import net.minecraftforge.registries.RegistryObject;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.DeferredRegister;

import net.minecraft.core.particles.SimpleParticleType;
import net.minecraft.core.particles.ParticleType;

import com.ashesembers.AshesembersMod;

public class AshesembersModParticleTypes {
	public static final DeferredRegister<ParticleType<?>> REGISTRY = DeferredRegister.create(ForgeRegistries.PARTICLE_TYPES, AshesembersMod.MODID);
	public static final RegistryObject<SimpleParticleType> ASHES = REGISTRY.register("ashes", () -> new SimpleParticleType(false));
	public static final RegistryObject<SimpleParticleType> EMBERS = REGISTRY.register("embers", () -> new SimpleParticleType(false));
}


// C:\Users\Max\Desktop\ashes_and_embers\src\main\java\com\ashesembers\init\AshesembersModParticles.java
package com.ashesembers.init;

import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.client.event.RegisterParticleProvidersEvent;
import net.minecraftforge.api.distmarker.Dist;

import com.ashesembers.client.particle.EmbersParticle;
import com.ashesembers.client.particle.AshesParticle;

@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD, value = Dist.CLIENT)
public class AshesembersModParticles {
	@SubscribeEvent
	public static void registerParticles(RegisterParticleProvidersEvent event) {
		event.registerSpriteSet(AshesembersModParticleTypes.ASHES.get(), AshesParticle::provider);
		event.registerSpriteSet(AshesembersModParticleTypes.EMBERS.get(), EmbersParticle::provider);
	}
}


// C:\Users\Max\Desktop\ashes_and_embers\src\main\java\com\ashesembers\procedures\ParticleEffectsProcedure.java
package com.ashesembers.procedures;

import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.eventbus.api.Event;
import net.minecraftforge.event.entity.living.LivingEvent;

import net.minecraft.world.level.LevelAccessor;
import net.minecraft.world.entity.Entity;
import net.minecraft.util.RandomSource;
import net.minecraft.util.Mth;
import net.minecraft.tags.TagKey;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.core.registries.Registries;
import net.minecraft.core.particles.SimpleParticleType;
import net.minecraft.core.BlockPos;

import javax.annotation.Nullable;

import com.ashesembers.init.AshesembersModParticleTypes;
import com.ashesembers.AshesembersMod;

@Mod.EventBusSubscriber
public class ParticleEffectsProcedure {
	@SubscribeEvent
	public static void onEntityTick(LivingEvent.LivingTickEvent event) {
		execute(event, event.getEntity().level(), event.getEntity().getX(), event.getEntity().getY(), event.getEntity().getZ(), event.getEntity());
	}

	public static void execute(LevelAccessor world, double x, double y, double z, Entity entity) {
		execute(null, world, x, y, z, entity);
	}

	private static void execute(@Nullable Event event, LevelAccessor world, double x, double y, double z, Entity entity) {
		if (entity == null)
			return;
		if (world.getBiome(BlockPos.containing(x, y, z)).is(TagKey.create(Registries.BIOME, new ResourceLocation("minecraft:is_overworld")))) {
			if (world.canSeeSkyFromBelowWater(BlockPos.containing(x, y, z))) {
				if (!entity.isUnderWater()) {
					AshesembersMod.queueServerWork(10, () -> {
						if (Math.random() < 0.4) {
							if (world instanceof ServerLevel _level)
								_level.sendParticles((SimpleParticleType) (AshesembersModParticleTypes.ASHES.get()), x, y, z, 28, (Mth.nextInt(RandomSource.create(), 1, 20)), (Mth.nextInt(RandomSource.create(), 3, 15)),
										(Mth.nextInt(RandomSource.create(), 1, 20)), 0.1);
						}
						if (Math.random() < 0.2) {
							if (world instanceof ServerLevel _level)
								_level.sendParticles((SimpleParticleType) (AshesembersModParticleTypes.EMBERS.get()), x, y, z, 20, (Mth.nextInt(RandomSource.create(), 1, 20)), (Mth.nextInt(RandomSource.create(), 3, 15)),
										(Mth.nextInt(RandomSource.create(), 1, 20)), 0.1);
						}
					});
				}
			}
		}
	}
}
}





